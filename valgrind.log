==============================
v0.0.1--normality version

$ valgrind ./a.out -v
==7022== Memcheck, a memory error detector
==7022== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==7022== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==7022== Command: ./a.out -v
==7022== 
v0.0.1
a[0]:0
==7022== 
==7022== HEAP SUMMARY:
==7022==     in use at exit: 0 bytes in 0 blocks
==7022==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated
==7022== 
==7022== All heap blocks were freed -- no leaks are possible
==7022== 
==7022== For counts of detected and suppressed errors, rerun with: -v
==7022== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)

==============================
v0.0.1-1
对于栈的访问越界，valgrind
检查不出来，在代码中加入对数字访问越界的访问，可见效果如下，没有什么特别之处。
$ valgrind ./a.out -v
==7261== Memcheck, a memory error detector
==7261== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==7261== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==7261== Command: ./a.out -v
==7261== 
v0.0.1-1
a[0]:0
a[10]:0
==7261== 
==7261== HEAP SUMMARY:
==7261==     in use at exit: 0 bytes in 0 blocks
==7261==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated
==7261== 
==7261== All heap blocks were freed -- no leaks are possible
==7261== 
==7261== For counts of detected and suppressed errors, rerun with: -v
==7261== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)

==============================
diff --git a/memory_init.c b/memory_init.c
index d42f898..a7150f4 100644
--- a/memory_init.c
+++ b/memory_init.c
@@ -1,7 +1,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#define VERSION	"v0.0.1-1"
+#define VERSION	"v0.0.2-0"
 void printf_version(int argc, char *argv[])
 {
 	int t;
@@ -19,12 +19,10 @@ void printf_version(int argc, char *argv[])
 int main(int argc, char *argv[])
 {
 	printf_version(argc, argv);
-
-	int a[1];
-	a[0] = 0;
-	fprintf(stdout, "a[0]:%d\n", a[0]);
-	a[10] = 0;
-	fprintf(stdout, "a[10]:%d\n", a[10]);
+	int *p;
+	p = malloc(sizeof(*p) * 2);
+	p[2]  = 0;
+	free(p);
 
 	return 0;
 }


$ valgrind ./a.out -v
==8042== Memcheck, a memory error detector
==8042== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==8042== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==8042== Command: ./a.out -v
==8042== 
v0.0.2-0
/* p[2]  = 0; */
==8042== Invalid write of size 4 
==8042==    at 0x8048522: main (memory_init.c:24)
==8042==  Address 0x41f4030 is 0 bytes after a block of size 8 alloc'd
==8042==    at 0x402BE68: malloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==8042==    by 0x8048516: main (memory_init.c:23)
==8042== 
==8042== 
==8042== HEAP SUMMARY:
==8042==     in use at exit: 0 bytes in 0 blocks
==8042==   total heap usage: 1 allocs, 1 frees, 8 bytes allocated
==8042== 
==8042== All heap blocks were freed -- no leaks are possible
==8042== 
==8042== For counts of detected and suppressed errors, rerun with: -v
==8042== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)

我们可以看到，无效的写发生在p[2]的地方，数组的最大下标应该是2-1=1。
程序提示我们用-v选项查看更详细的信息：

$ valgrind -v ./a.out -v
==8086== Memcheck, a memory error detector
==8086== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==8086== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==8086== Command: ./a.out -v
==8086== 
--8086-- Valgrind options:
--8086--    --suppressions=/usr/lib/valgrind/debian-libc6-dbg.supp
--8086--    -v
--8086-- Contents of /proc/version:
--8086--   Linux version 3.2.0-55-generic (buildd@allspice) (gcc version 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5) ) #85-Ubuntu SMP Wed Oct 2 13:43:27 UTC 2013
--8086-- Arch and hwcaps: X86, x86-sse1-sse2
--8086-- Page sizes: currently 4096, max supported 4096
--8086-- Valgrind library directory: /usr/lib/valgrind
--8086-- Reading syms from /lib/i386-linux-gnu/ld-2.15.so (0x4000000)
--8086--   Considering /lib/i386-linux-gnu/ld-2.15.so ..
--8086--   .. CRC mismatch (computed a9bcb2b6 wanted 8af3f2f5)
--8086--   Considering /usr/lib/debug/lib/i386-linux-gnu/ld-2.15.so ..
--8086--   .. CRC is valid
--8086-- Reading syms from /mnt/data/gitstorage/valgrind/a.out (0x8048000)
--8086-- Reading syms from /usr/lib/valgrind/memcheck-x86-linux (0x38000000)
--8086--   Considering /usr/lib/valgrind/memcheck-x86-linux ..
--8086--   .. CRC mismatch (computed 2a2bce46 wanted 9ac1affc)
--8086--    object doesn't have a symbol table
--8086--    object doesn't have a dynamic symbol table
--8086-- Reading suppressions file: /usr/lib/valgrind/debian-libc6-dbg.supp
--8086-- Reading suppressions file: /usr/lib/valgrind/default.supp
==8086== embedded gdbserver: reading from /tmp/vgdb-pipe-from-vgdb-to-8086-by-zly-on-???
==8086== embedded gdbserver: writing to   /tmp/vgdb-pipe-to-vgdb-from-8086-by-zly-on-???
==8086== embedded gdbserver: shared mem   /tmp/vgdb-pipe-shared-mem-vgdb-8086-by-zly-on-???
==8086== 
==8086== TO CONTROL THIS PROCESS USING vgdb (which you probably
==8086== don't want to do, unless you know exactly what you're doing,
==8086== or are doing some strange experiment):
==8086==   /usr/lib/valgrind/../../bin/vgdb --pid=8086 ...command...
==8086== 
==8086== TO DEBUG THIS PROCESS USING GDB: start GDB like this
==8086==   /path/to/gdb ./a.out
==8086== and then give GDB the following command
==8086==   target remote | /usr/lib/valgrind/../../bin/vgdb --pid=8086
==8086== --pid is optional if only one valgrind process is running
==8086== 
--8086-- REDIR: 0x40182e0 (strlen) redirected to 0x38056b04 (???)
--8086-- REDIR: 0x4018060 (index) redirected to 0x38056adf (???)
--8086-- Reading syms from /usr/lib/valgrind/vgpreload_core-x86-linux.so (0x4025000)
--8086--   Considering /usr/lib/valgrind/vgpreload_core-x86-linux.so ..
--8086--   .. CRC mismatch (computed 33f4d79f wanted ac058c14)
--8086--    object doesn't have a symbol table
--8086-- Reading syms from /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so (0x4028000)
--8086--   Considering /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so ..
--8086--   .. CRC mismatch (computed 8c6a0645 wanted b38afa17)
--8086--    object doesn't have a symbol table
--8086-- Reading syms from /lib/i386-linux-gnu/libc-2.15.so (0x4049000)
--8086--   Considering /lib/i386-linux-gnu/libc-2.15.so ..
--8086--   .. CRC mismatch (computed a80412a6 wanted a2743b32)
--8086--   Considering /usr/lib/debug/lib/i386-linux-gnu/libc-2.15.so ..
--8086--   .. CRC is valid
--8086-- REDIR: 0x40c6d50 (strnlen) redirected to 0x40254a0 (_vgnU_ifunc_wrapper)
--8086-- REDIR: 0x40c82a0 (strncasecmp) redirected to 0x40254a0 (_vgnU_ifunc_wrapper)
--8086-- REDIR: 0x40c6ef0 (__GI_strrchr) redirected to 0x402c1b0 (__GI_strrchr)
--8086-- REDIR: 0x40c6c90 (__GI_strlen) redirected to 0x402c670 (__GI_strlen)
--8086-- REDIR: 0x40c62e0 (__GI_strchr) redirected to 0x402c2d0 (__GI_strchr)
--8086-- REDIR: 0x40c95c0 (strchrnul) redirected to 0x402ebe0 (strchrnul)
v0.0.2-0
--8086-- REDIR: 0x40c2ec0 (free) redirected to 0x402b000 (free)
--8086-- REDIR: 0x40c29e0 (malloc) redirected to 0x402be00 (malloc)
==8086== Invalid write of size 4
==8086==    at 0x8048522: main (memory_init.c:24)
==8086==  Address 0x41f4030 is 0 bytes after a block of size 8 alloc'd
==8086==    at 0x402BE68: malloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==8086==    by 0x8048516: main (memory_init.c:23)
==8086== 
==8086== 
==8086== HEAP SUMMARY:
==8086==     in use at exit: 0 bytes in 0 blocks
==8086==   total heap usage: 1 allocs, 1 frees, 8 bytes allocated
==8086== 
==8086== All heap blocks were freed -- no leaks are possible
==8086== 
==8086== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
==8086== 
==8086== 1 errors in context 1 of 1:
==8086== Invalid write of size 4

/* invald write line number */
==8086==    at 0x8048522: main (memory_init.c:24)
==8086==  Address 0x41f4030 is 0 bytes after a block of size 8 alloc'd
==8086==    at 0x402BE68: malloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==8086==    by 0x8048516: main (memory_init.c:23)
==8086== 
==8086== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
我们可以看到写无效的行数。

==============================

"v0.0.2-1"
LEAK memory -- 内存泄漏

diff --git a/memory_init.c b/memory_init.c
index a7150f4..2cef044 100644
--- a/memory_init.c
+++ b/memory_init.c
@@ -1,7 +1,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#define VERSION	"v0.0.2-0"
+#define VERSION	"v0.0.2-1"
 void printf_version(int argc, char *argv[])
 {
 	int t;
@@ -21,8 +21,6 @@ int main(int argc, char *argv[])
 	printf_version(argc, argv);
 	int *p;
 	p = malloc(sizeof(*p) * 2);
-	p[2]  = 0;
-	free(p);
 
 	return 0;
 }


$ valgrind ./a.out -v
==8390== Memcheck, a memory error detector
==8390== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==8390== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==8390== Command: ./a.out -v
==8390== 
v0.0.2-0
==8390== 

/* leak memory summary */
可以看见在使用当中退出，申请了一次，却没有释放。
==8390== HEAP SUMMARY:
==8390==     in use at exit: 8 bytes in 1 blocks
==8390==   total heap usage: 1 allocs, 0 frees, 8 bytes allocated
==8390== 
==8390== LEAK SUMMARY:
==8390==    definitely lost: 8 bytes in 1 blocks
==8390==    indirectly lost: 0 bytes in 0 blocks
==8390==      possibly lost: 0 bytes in 0 blocks
==8390==    still reachable: 0 bytes in 0 blocks
==8390==         suppressed: 0 bytes in 0 blocks
==8390== Rerun with --leak-check=full to see details of leaked memory
==8390== 
==8390== For counts of detected and suppressed errors, rerun with: -v
==8390== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)

我们使用--leak-check=full选项进一步查看内存泄漏的位置：

$ valgrind --leak-check=full ./a.out -v
==8454== Memcheck, a memory error detector
==8454== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==8454== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==8454== Command: ./a.out -v
==8454== 
v0.0.2-0
==8454== 
==8454== HEAP SUMMARY:
==8454==     in use at exit: 8 bytes in 1 blocks
==8454==   total heap usage: 1 allocs, 0 frees, 8 bytes allocated
==8454== 
==8454== 8 bytes in 1 blocks are definitely lost in loss record 1 of 1
==8454==    at 0x402BE68: malloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)

/* leaked memory position */

==8454==    by 0x80484E6: main (memory_init.c:23)
==8454== 
==8454== LEAK SUMMARY:
==8454==    definitely lost: 8 bytes in 1 blocks
==8454==    indirectly lost: 0 bytes in 0 blocks
==8454==      possibly lost: 0 bytes in 0 blocks
==8454==    still reachable: 0 bytes in 0 blocks
==8454==         suppressed: 0 bytes in 0 blocks
==8454== 
==8454== For counts of detected and suppressed errors, rerun with: -v
==8454== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
==============================

"v0.0.2-2"
repaeted free == 重复释放

diff --git a/memory_init.c b/memory_init.c
index 2cef044..db0c2b0 100644
--- a/memory_init.c
+++ b/memory_init.c
@@ -1,7 +1,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#define VERSION	"v0.0.2-1"
+#define VERSION	"v0.0.2-2"
 void printf_version(int argc, char *argv[])
 {
 	int t;
@@ -21,6 +21,8 @@ int main(int argc, char *argv[])
 	printf_version(argc, argv);
 	int *p;
 	p = malloc(sizeof(*p) * 2);
+	free(p);
+	free(p);
 
 	return 0;
 }

$ valgrind ./a.out -v
==8803== Memcheck, a memory error detector
==8803== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==8803== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==8803== Command: ./a.out -v
==8803== 
v0.0.2-1
		/* repeated free for heap */
==8803== Invalid free() / delete / delete[] / realloc()
==8803==    at 0x402B06C: free (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==8803==    by 0x8048532: main (memory_init.c:25)
==8803==  Address 0x41f4028 is 0 bytes inside a block of size 8 free'd
==8803==    at 0x402B06C: free (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==8803==    by 0x8048526: main (memory_init.c:24)
==8803== 
==8803== 
==8803== HEAP SUMMARY:
==8803==     in use at exit: 0 bytes in 0 blocks
		/* alloc one, buf free two */
==8803==   total heap usage: 1 allocs, 2 frees, 8 bytes allocated
==8803== 
==8803== All heap blocks were freed -- no leaks are possible
==8803== 
==8803== For counts of detected and suppressed errors, rerun with: -v
==8803== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)


我们使用-v选项进一步查看详情：

$ valgrind -v ./a.out -v
==8845== Memcheck, a memory error detector
==8845== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==8845== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==8845== Command: ./a.out -v
==8845== 
--8845-- Valgrind options:
--8845--    --suppressions=/usr/lib/valgrind/debian-libc6-dbg.supp
--8845--    -v
--8845-- Contents of /proc/version:
--8845--   Linux version 3.2.0-55-generic (buildd@allspice) (gcc version 4.6.3
		(Ubuntu/Linaro 4.6.3-1ubuntu5) ) #85-Ubuntu SMP Wed Oct 2
13:43:27 UTC 2013
--8845-- Arch and hwcaps: X86, x86-sse1-sse2
--8845-- Page sizes: currently 4096, max supported 4096
--8845-- Valgrind library directory: /usr/lib/valgrind
--8845-- Reading syms from /lib/i386-linux-gnu/ld-2.15.so (0x4000000)
--8845--   Considering /lib/i386-linux-gnu/ld-2.15.so ..
--8845--   .. CRC mismatch (computed a9bcb2b6 wanted 8af3f2f5)
--8845--   Considering /usr/lib/debug/lib/i386-linux-gnu/ld-2.15.so ..
--8845--   .. CRC is valid
--8845-- Reading syms from /mnt/data/gitstorage/valgrind/a.out (0x8048000)
--8845-- Reading syms from /usr/lib/valgrind/memcheck-x86-linux (0x38000000)
--8845--   Considering /usr/lib/valgrind/memcheck-x86-linux ..
--8845--   .. CRC mismatch (computed 2a2bce46 wanted 9ac1affc)
--8845--    object doesn't have a symbol table
--8845--    object doesn't have a dynamic symbol table
--8845-- Reading suppressions file: /usr/lib/valgrind/debian-libc6-dbg.supp
--8845-- Reading suppressions file: /usr/lib/valgrind/default.supp
==8845== embedded gdbserver: reading from
/tmp/vgdb-pipe-from-vgdb-to-8845-by-zly-on-???
==8845== embedded gdbserver: writing to
/tmp/vgdb-pipe-to-vgdb-from-8845-by-zly-on-???
==8845== embedded gdbserver: shared mem
/tmp/vgdb-pipe-shared-mem-vgdb-8845-by-zly-on-???
==8845== 
==8845== TO CONTROL THIS PROCESS USING vgdb (which you probably
		==8845== don't want to do, unless you know exactly what you're
		doing,
		==8845== or are doing some strange experiment):
==8845==   /usr/lib/valgrind/../../bin/vgdb --pid=8845 ...command...
==8845== 
==8845== TO DEBUG THIS PROCESS USING GDB: start GDB like this
==8845==   /path/to/gdb ./a.out
==8845== and then give GDB the following command
==8845==   target remote | /usr/lib/valgrind/../../bin/vgdb --pid=8845
==8845== --pid is optional if only one valgrind process is running
==8845== 
--8845-- REDIR: 0x40182e0 (strlen) redirected to 0x38056b04 (???)
--8845-- REDIR: 0x4018060 (index) redirected to 0x38056adf (???)
--8845-- Reading syms from /usr/lib/valgrind/vgpreload_core-x86-linux.so
(0x4025000)
--8845--   Considering /usr/lib/valgrind/vgpreload_core-x86-linux.so ..
--8845--   .. CRC mismatch (computed 33f4d79f wanted ac058c14)
--8845--    object doesn't have a symbol table
--8845-- Reading syms from /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so
(0x4028000)
--8845--   Considering /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so ..
--8845--   .. CRC mismatch (computed 8c6a0645 wanted b38afa17)
--8845--    object doesn't have a symbol table
--8845-- Reading syms from /lib/i386-linux-gnu/libc-2.15.so (0x4049000)
--8845--   Considering /lib/i386-linux-gnu/libc-2.15.so ..
--8845--   .. CRC mismatch (computed a80412a6 wanted a2743b32)
--8845--   Considering /usr/lib/debug/lib/i386-linux-gnu/libc-2.15.so ..
--8845--   .. CRC is valid
--8845-- REDIR: 0x40c6d50 (strnlen) redirected to 0x40254a0
(_vgnU_ifunc_wrapper)
--8845-- REDIR: 0x40c82a0 (strncasecmp) redirected to 0x40254a0
(_vgnU_ifunc_wrapper)
--8845-- REDIR: 0x40c6ef0 (__GI_strrchr) redirected to 0x402c1b0
(__GI_strrchr)
--8845-- REDIR: 0x40c6c90 (__GI_strlen) redirected to 0x402c670 (__GI_strlen)
--8845-- REDIR: 0x40c62e0 (__GI_strchr) redirected to 0x402c2d0 (__GI_strchr)
--8845-- REDIR: 0x40c95c0 (strchrnul) redirected to 0x402ebe0 (strchrnul)
v0.0.2-1
--8845-- REDIR: 0x40c2ec0 (free) redirected to 0x402b000 (free)
--8845-- REDIR: 0x40c29e0 (malloc) redirected to 0x402be00 (malloc)
==8845== Invalid free() / delete / delete[] / realloc()
==8845==    at 0x402B06C: free (in
		/usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==8845==    by 0x8048532: main (memory_init.c:25)
==8845==  Address 0x41f4028 is 0 bytes inside a block of size 8 free'd
==8845==    at 0x402B06C: free (in
		/usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==8845==    by 0x8048526: main (memory_init.c:24)
==8845== 
==8845== 
==8845== HEAP SUMMARY:
==8845==     in use at exit: 0 bytes in 0 blocks
==8845==   total heap usage: 1 allocs, 2 frees, 8 bytes allocated
==8845== 
==8845== All heap blocks were freed -- no leaks are possible
==8845== 
==8845== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
==8845== 
==8845== 1 errors in context 1 of 1:
		/* error free position */
==8845== Invalid free() / delete / delete[] / realloc()
==8845==    at 0x402B06C: free (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==8845==    by 0x8048532: main (memory_init.c:25)
		/* first free success */
==8845==  Address 0x41f4028 is 0 bytes inside a block of size 8 free'd
==8845==    at 0x402B06C: free (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==8845==    by 0x8048526: main (memory_init.c:24)
==8845== 
==8845== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
上文注释的地方分别是一次正确释放内存和第二次错误的释放操作。

==============================
+#define VERSION	"v0.0.1-2"
uninitialised values and
Conditional jump or move depends on uninitialised value
使用前未初始化的堆栈，进一步讲，使用了未初始化的值作为了判断条件。

diff --git a/memory_init.c b/memory_init.c
index db0c2b0..7f5be8e 100644
--- a/memory_init.c
+++ b/memory_init.c
@@ -1,7 +1,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#define VERSION	"v0.0.2-2"
+#define VERSION	"v0.0.1-2"

int main(int argc, char *argv[])
{
        printf_version(argc, argv);

        int a[2];
        if (1 == a[0]) {
                fprintf(stdout, "a[0] is 0\n");
        }   

        return 0;
}

输出查看：
$ valgrind ./a.out -v
==2899== Memcheck, a memory error detector
==2899== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==2899== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==2899== Command: ./a.out -v
==2899== 
v0.0.1-2
	/* if (1 == a[0]) , but a[0] uninitialised */
==2899== Conditional jump or move depends on uninitialised value(s)
==2899==    at 0x80484E2: main (memory_init.c:28)
==2899== 
==2899== 
==2899== HEAP SUMMARY:
==2899==     in use at exit: 0 bytes in 0 blocks
==2899==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated
==2899== 
==2899== All heap blocks were freed -- no leaks are possible
==2899== 
==2899== For counts of detected and suppressed errors, rerun with: -v
==2899== Use --track-origins=yes to see where uninitialised values come from
==2899== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)

使用--track-origins=yes查看未初始化的值

$ valgrind --track-origins=yes ./a.out -v
==2907== Memcheck, a memory error detector
==2907== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==2907== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==2907== Command: ./a.out -v
==2907== 
v0.0.1-2
	/* depends uninitialised value on 28 line */
==2907== Conditional jump or move depends on uninitialised value(s)
==2907==    at 0x80484E2: main (memory_init.c:28)

	/* here show positon of uninitialised value */

==2907==  Uninitialised value was created by a stack allocation
==2907==    at 0x80484C6: main (memory_init.c:20)
==2907== 
==2907== 
==2907== HEAP SUMMARY:
==2907==     in use at exit: 0 bytes in 0 blocks
==2907==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated
==2907== 
==2907== All heap blocks were freed -- no leaks are possible
==2907== 
==2907== For counts of detected and suppressed errors, rerun with: -v
==2907== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)

-v feature detile of errors
$ valgrind -v ./a.out -v
......
==2914== 1 errors in context 1 of 1:
==2914== Conditional jump or move depends on uninitialised value(s)
==2914==    at 0x80484E2: main (memory_init.c:28)
==2914== 
==2914== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
......

==============================
 19 int main(int argc, char *argv[])
 20 {
 21         printf_version(argc, argv);
 22         char a[10] = "1234567890";
 23         char *p = a + 2;
 24 #include <string.h>
 25         strcpy(a, p);
 26 
 27         return 0;
 28 }

$ valgrind ./a.out -v 
==4498== Memcheck, a memory error detector
==4498== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==4498== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==4498== Command: ./a.out -v
==4498== 
v0.0.1-3
	/* memory overlap, 提示内存重叠：*/
==4498== Source and destination overlap in strcpy(0xbea5c1c2, 0xbea5c1c4)
==4498==    at 0x402C73B: strcpy (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==4498==    by 0x8048574: main (memory_init.c:25)
==4498== 
==4498== 
==4498== HEAP SUMMARY:
==4498==     in use at exit: 0 bytes in 0 blocks
==4498==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated
==4498== 
==4498== All heap blocks were freed -- no leaks are possible
==4498== 
==4498== For counts of detected and suppressed errors, rerun with: -v
==4498== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)

以下是再次加-v选项运行时对错误部分的提示：
==4507== 1 errors in context 1 of 1:
==4507== Source and destination overlap in strcpy(0xbec351c2, 0xbec351c4)
==4507==    at 0x402C73B: strcpy (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==4507==    by 0x8048574: main (memory_init.c:25)
==4507== 
==4507== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
==============================
 invalid write already free heap
写已经释放的内存

 19 int main(int argc, char *argv[])
 20 {
 21         printf_version(argc, argv);
 22         char *p;
 23 #define STRNUM  "1234567890"
 24         p = malloc(sizeof(STRNUM));
 25 #include <string.h>
 26         memcpy(p, STRNUM, sizeof(STRNUM));
 27 #undef STRNUM
 28         free(p);
 29         p[0] = 0;
 30 
 31         return 0;
 32 }

$ valgrind ./a.out -v
==5166== Memcheck, a memory error detector
==5166== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==5166== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==5166== Command: ./a.out -v
==5166== 
v0.0.2-3
	/* already free, but p[0] = 0 on line 29 */
==5166== Invalid write of size 1
==5166==    at 0x804854D: main (memory_init.c:29)
==5166==  Address 0x41f4028 is 0 bytes inside a block of size 11 free'd
==5166==    at 0x402B06C: free (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==5166==    by 0x8048548: main (memory_init.c:28)
==5166== 
==5166== 
==5166== HEAP SUMMARY:
==5166==     in use at exit: 0 bytes in 0 blocks
==5166==   total heap usage: 1 allocs, 1 frees, 11 bytes allocated
==5166== 
==5166== All heap blocks were freed -- no leaks are possible
==5166== 
==5166== For counts of detected and suppressed errors, rerun with: -v
==5166== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)

usega "-v" option print:
......
==5170== 1 errors in context 1 of 1:
==5170== Invalid write of size 1
==5170==    at 0x804854D: main (memory_init.c:29)
==5170==  Address 0x41f4028 is 0 bytes inside a block of size 11 free'd
==5170==    at 0x402B06C: free (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==5170==    by 0x8048548: main (memory_init.c:28)
......

==============================
2014年 12月 15日 星期一 10:38:02 CST
==============================
below example via reference site:
http://www.ibm.com/developerworks/cn/linux/l-cn-valgrind/index.html
==============================
写的内存指向了未初始化的字节(字符串)

  1 #include <stdio.h>
  2 #include <unistd.h>
  3 
  4 int main(int argc, char *argv[])
  5 {
  6     char memory[10];
  7     int i;
  8     for (i = 0; i < 10; i++) {
  9         write(STDOUT_FILENO, memory + i, sizeof(*(memory + i)));
 10     }
 11     return 0;
 12 }

[root@zhangly valgrind_usage]# gcc -g uninit_memory.c 
[root@zhangly valgrind_usage]# valgrind
valgrind           valgrind-listener  
[root@zhangly valgrind_usage]# valgrind ./a.out 
==11793== Memcheck, a memory error detector
==11793== Copyright (C) 2002-2009, and GNU GPL'd, by Julian Seward et al.
==11793== Using Valgrind-3.5.0 and LibVEX; rerun with -h for copyright info
==11793== Command: ./a.out
==11793== /* 写的内存指向了未初始化的字节 */
==11793== Syscall param write(buf) points to uninitialised byte(s)
==11793==    at 0x4EEE230: __write_nocancel (in /lib64/libc-2.5.so)
==11793==    by 0x4004CA: main (uninit_memory.c:9)
==11793==  Address 0x7ff000890 is on thread 1's stack
==11793== 
�       �==11793== 
==11793== HEAP SUMMARY:
==11793==     in use at exit: 0 bytes in 0 blocks
==11793==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated
==11793== 
==11793== All heap blocks were freed -- no leaks are possible
==11793== 
==11793== For counts of detected and suppressed errors, rerun with: -v
==11793== Use --track-origins=yes to see where uninitialised values come from
==11793== ERROR SUMMARY: 10 errors from 1 contexts (suppressed: 4 from 4)

==============================
fprint函数引用未初始化字符串例子：
用不同的函数调用的效果可能有差别，用标准c函数调用，可能还会进一步调用系统函数
所以引用未有问题的内存的次数也会相应增加，我们可以看到有问题的行数为第九行。

  1 #include <stdio.h>
  2 #include <unistd.h>
  3 
  4 int main(int argc, char *argv[])
  5 {
  6     char memory[10];
  7     int i;
  8     for (i = 0; i < 10; i++) {
  9         fprintf(stdout, "memory [%d]:%c\n", i, memory[i]);
 10     }
 11     return 0;
 12 }
[root@zhangly valgrind_usage]# valgrind ./a.out 
==8930== Memcheck, a memory error detector
==8930== Copyright (C) 2002-2009, and GNU GPL'd, by Julian Seward et al.
==8930== Using Valgrind-3.5.0 and LibVEX; rerun with -h for copyright info
==8930== Command: ./a.out
==8930== 
==8930== Conditional jump or move depends on uninitialised value(s)
==8930==    at 0x4E92138: _IO_file_overflow@@GLIBC_2.2.5 (in /lib64/libc-2.5.so)
==8930==    by 0x4E6E3A9: vfprintf (in /lib64/libc-2.5.so)
==8930==    by 0x4E73C67: fprintf (in /lib64/libc-2.5.so)
==8930==    by 0x400515: main (uninit_memory.c:9)
==8930== 
==8930== Conditional jump or move depends on uninitialised value(s)
==8930==    at 0x4E9216B: _IO_file_overflow@@GLIBC_2.2.5 (in /lib64/libc-2.5.so)
==8930==    by 0x4E6E3A9: vfprintf (in /lib64/libc-2.5.so)
==8930==    by 0x4E73C67: fprintf (in /lib64/libc-2.5.so)
==8930==    by 0x400515: main (uninit_memory.c:9)
==8930== 
==8930== Conditional jump or move depends on uninitialised value(s)
==8930==    at 0x4E6E3AD: vfprintf (in /lib64/libc-2.5.so)
==8930==    by 0x4E73C67: fprintf (in /lib64/libc-2.5.so)
==8930==    by 0x400515: main (uninit_memory.c:9)
==8930== 
==8930== Syscall param write(buf) points to uninitialised byte(s)
==8930==    at 0x4EEE230: __write_nocancel (in /lib64/libc-2.5.so)
==8930==    by 0x4E91BB2: _IO_file_write@@GLIBC_2.2.5 (in /lib64/libc-2.5.so)
==8930==    by 0x4E91AC5: _IO_do_write@@GLIBC_2.2.5 (in /lib64/libc-2.5.so)
==8930==    by 0x4E92F21: _IO_file_xsputn@@GLIBC_2.2.5 (in /lib64/libc-2.5.so)
==8930==    by 0x4E69FFA: vfprintf (in /lib64/libc-2.5.so)
==8930==    by 0x4E73C67: fprintf (in /lib64/libc-2.5.so)
==8930==    by 0x400515: main (uninit_memory.c:9)
==8930==  Address 0x401e00b is not stack'd, malloc'd or (recently) free'd
==8930== 
memory [0]:�
memory [1]:
memory [2]:
memory [3]:�
memory [4]:
memory [5]:
memory [6]:
memory [7]:
memory [8]:
memory [9]:
==8930== 
==8930== HEAP SUMMARY:
==8930==     in use at exit: 0 bytes in 0 blocks
==8930==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated
==8930== 
==8930== All heap blocks were freed -- no leaks are possible
==8930== 
==8930== For counts of detected and suppressed errors, rerun with: -v
==8930== Use --track-origins=yes to see where uninitialised values come from
==8930== ERROR SUMMARY: 40 errors from 4 contexts (suppressed: 4 from 4)

==============================
引用未初始化的整形数据：
我们可以看到用fprint引用时会多提醒引用的是8字节大小。

  1 #include <stdio.h>
  2 #include <unistd.h>
  3 
  4 int main(int argc, char *argv[])
  5 {
  6     int m;
  7 
  8     write(STDOUT_FILENO, &m, sizeof(m));
  9     fprintf(stdout, "m:%d\n", m);
 10 
 11     return 0;
 12 }


[root@zhangly valgrind_usage]# gcc -g uninit_memory.c 
[root@zhangly valgrind_usage]# valgrind ./a.out 
==16221== Memcheck, a memory error detector
==16221== Copyright (C) 2002-2009, and GNU GPL'd, by Julian Seward et al.
==16221== Using Valgrind-3.5.0 and LibVEX; rerun with -h for copyright info
==16221== Command: ./a.out
==16221== 
==16221== Syscall param write(buf) points to uninitialised byte(s)
==16221==    at 0x4EEE230: __write_nocancel (in /lib64/libc-2.5.so)
==16221==    by 0x400549: main (uninit_memory.c:8)
==16221==  Address 0x7ff00089c is on thread 1's stack
==16221== 
==16221== Use of uninitialised value of size 8
==16221==    at 0x4E68B2D: _itoa_word (in /lib64/libc-2.5.so)
==16221==    by 0x4E6BF12: vfprintf (in /lib64/libc-2.5.so)
==16221==    by 0x4E73C67: fprintf (in /lib64/libc-2.5.so)
==16221==    by 0x400562: main (uninit_memory.c:9)
==16221== 
==16221== Conditional jump or move depends on uninitialised value(s)
==16221==    at 0x4E68B37: _itoa_word (in /lib64/libc-2.5.so)
==16221==    by 0x4E6BF12: vfprintf (in /lib64/libc-2.5.so)
==16221==    by 0x4E73C67: fprintf (in /lib64/libc-2.5.so)
==16221==    by 0x400562: main (uninit_memory.c:9)
==16221== 
==16221== Conditional jump or move depends on uninitialised value(s)
==16221==    at 0x4E6BF98: vfprintf (in /lib64/libc-2.5.so)
==16221==    by 0x4E73C67: fprintf (in /lib64/libc-2.5.so)
==16221==    by 0x400562: main (uninit_memory.c:9)
==16221== 
==16221== Conditional jump or move depends on uninitialised value(s)
==16221==    at 0x4E6C7A6: vfprintf (in /lib64/libc-2.5.so)
==16221==    by 0x4E73C67: fprintf (in /lib64/libc-2.5.so)
==16221==    by 0x400562: main (uninit_memory.c:9)
==16221== 
==16221== Conditional jump or move depends on uninitialised value(s)
==16221==    at 0x4E6A649: vfprintf (in /lib64/libc-2.5.so)
==16221==    by 0x4E73C67: fprintf (in /lib64/libc-2.5.so)
==16221==    by 0x400562: main (uninit_memory.c:9)
==16221== 
m:0
==16221== 
==16221== HEAP SUMMARY:
==16221==     in use at exit: 0 bytes in 0 blocks
==16221==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated
==16221== 
==16221== All heap blocks were freed -- no leaks are possible
==16221== 
==16221== For counts of detected and suppressed errors, rerun with: -v
==16221== Use --track-origins=yes to see where uninitialised values come from
==16221== ERROR SUMMARY: 6 errors from 6 contexts (suppressed: 4 from 4)

==============================
部分初始化或未显示初始化的堆，也会被检查。
  1 #include <stdio.h>
  2 #include <unistd.h>
  3 #include <stdlib.h>
  4 
  5 int main(int argc, char *argv[])
  6 {
  7     char *p;
  8     int i;
  9     p = malloc(sizeof(*p) * 10);
 10     p[0] = 0;
 11     for (i = 0; i < 10; i++) {
 12         fprintf(stdout, "p[%d]:%c\n", i, p[i]);
 13     }
 14     free(p);
 15 
 16     return 0;
 17 }
[root@zhangly valgrind_usage]# gcc -g uninit_memory.c 
[root@zhangly valgrind_usage]# valgrind ./a.out 
==12656== Memcheck, a memory error detector
==12656== Copyright (C) 2002-2009, and GNU GPL'd, by Julian Seward et al.
==12656== Using Valgrind-3.5.0 and LibVEX; rerun with -h for copyright info
==12656== Command: ./a.out
==12656== 
p[0]:
==12656== Conditional jump or move depends on uninitialised value(s)
==12656==    at 0x4E92138: _IO_file_overflow@@GLIBC_2.2.5 (in /lib64/libc-2.5.so)
==12656==    by 0x4E6E3A9: vfprintf (in /lib64/libc-2.5.so)
==12656==    by 0x4E73C67: fprintf (in /lib64/libc-2.5.so)
==12656==    by 0x4005BC: main (uninit_memory.c:12)
==12656== 
==12656== Conditional jump or move depends on uninitialised value(s)
==12656==    at 0x4E9216B: _IO_file_overflow@@GLIBC_2.2.5 (in /lib64/libc-2.5.so)
==12656==    by 0x4E6E3A9: vfprintf (in /lib64/libc-2.5.so)
==12656==    by 0x4E73C67: fprintf (in /lib64/libc-2.5.so)
==12656==    by 0x4005BC: main (uninit_memory.c:12)
==12656== 
==12656== Conditional jump or move depends on uninitialised value(s)
==12656==    at 0x4E6E3AD: vfprintf (in /lib64/libc-2.5.so)
==12656==    by 0x4E73C67: fprintf (in /lib64/libc-2.5.so)
==12656==    by 0x4005BC: main (uninit_memory.c:12)
==12656== 
==12656== Syscall param write(buf) points to uninitialised byte(s)
==12656==    at 0x4EEE230: __write_nocancel (in /lib64/libc-2.5.so)
==12656==    by 0x4E91BB2: _IO_file_write@@GLIBC_2.2.5 (in /lib64/libc-2.5.so)
==12656==    by 0x4E91AC5: _IO_do_write@@GLIBC_2.2.5 (in /lib64/libc-2.5.so)
==12656==    by 0x4E92F21: _IO_file_xsputn@@GLIBC_2.2.5 (in /lib64/libc-2.5.so)
==12656==    by 0x4E69FFA: vfprintf (in /lib64/libc-2.5.so)
==12656==    by 0x4E73C67: fprintf (in /lib64/libc-2.5.so)
==12656==    by 0x4005BC: main (uninit_memory.c:12)
==12656==  Address 0x401e005 is not stack'd, malloc'd or (recently) free'd
==12656== 
p[1]:
p[2]:
p[3]:
p[4]:
p[5]:
p[6]:
p[7]:
p[8]:
p[9]:
==12656== 
==12656== HEAP SUMMARY:
==12656==     in use at exit: 0 bytes in 0 blocks
==12656==   total heap usage: 1 allocs, 1 frees, 10 bytes allocated
==12656== 
==12656== All heap blocks were freed -- no leaks are possible
==12656== 
==12656== For counts of detected and suppressed errors, rerun with: -v
==12656== Use --track-origins=yes to see where uninitialised values come from
==12656== ERROR SUMMARY: 36 errors from 4 contexts (suppressed: 4 from 4)

我们可以看到第12行报错，显示未初始化！

==============================
内存访问边界越界，读写操作。
以下第11行为无效的写，第13行是系统调用无效的读，第16行是c标准调用无效的读。
  1 #include <stdio.h>
  2 #include <stdlib.h>
  3 #include <unistd.h>
  4 
  5 int main(int argc, char *argv[])
  6 {
  7     char *p = malloc(sizeof(*p) * 2);
  8     int i;
  9     for (i = 0; i < 3; i++) {
 10         /* Invalid write of size 1 */
 11         p[i] = '0' + i;
 12         /* Syscall param write(buf) points to unaddressable byte(s) */
 13         write(STDOUT_FILENO, &p[i], sizeof(*(p + i)));
 14 
 15         /* Invalid read of size 1 */
 16         fprintf(stdout, "p[%d]:%c\n", p[i]);
 17     }
 18 
 19     return 0;
 20 }
以下为报告：
[root@zhangly valgrind_usage]# gcc -g over_border.c 
[root@zhangly valgrind_usage]# valgrind ./a.out 
==26567== Memcheck, a memory error detector
==26567== Copyright (C) 2002-2009, and GNU GPL'd, by Julian Seward et al.
==26567== Using Valgrind-3.5.0 and LibVEX; rerun with -h for copyright info
==26567== Command: ./a.out
==26567== 
0p[48]:0
1p[49]:0
==26567== Invalid write of size 1
==26567==    at 0x4005A0: main (over_border.c:11)
==26567==  Address 0x5180042 is 0 bytes after a block of size 2 alloc'd
==26567==    at 0x4C2210C: malloc (vg_replace_malloc.c:195)
==26567==    by 0x400580: main (over_border.c:7)
==26567== 
==26567== Syscall param write(buf) points to unaddressable byte(s)
==26567==    at 0x4EEE230: __write_nocancel (in /lib64/libc-2.5.so)
==26567==    by 0x4005BC: main (over_border.c:13)
==26567==  Address 0x5180042 is 0 bytes after a block of size 2 alloc'd
==26567==    at 0x4C2210C: malloc (vg_replace_malloc.c:195)
==26567==    by 0x400580: main (over_border.c:7)
==26567== 
2==26567== Invalid read of size 1
==26567==    at 0x4005C6: main (over_border.c:16)
==26567==  Address 0x5180042 is 0 bytes after a block of size 2 alloc'd
==26567==    at 0x4C2210C: malloc (vg_replace_malloc.c:195)
==26567==    by 0x400580: main (over_border.c:7)
==26567== 
p[50]:0
==26567== 
==26567== HEAP SUMMARY:
==26567==     in use at exit: 2 bytes in 1 blocks
==26567==   total heap usage: 1 allocs, 0 frees, 2 bytes allocated
==26567== 
==26567== LEAK SUMMARY:
==26567==    definitely lost: 2 bytes in 1 blocks
==26567==    indirectly lost: 0 bytes in 0 blocks
==26567==      possibly lost: 0 bytes in 0 blocks
==26567==    still reachable: 0 bytes in 0 blocks
==26567==         suppressed: 0 bytes in 0 blocks
==26567== Rerun with --leak-check=full to see details of leaked memory
==26567== 
==26567== For counts of detected and suppressed errors, rerun with: -v
==26567== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 4 from 4)

